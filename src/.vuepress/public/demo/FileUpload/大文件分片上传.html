<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>大文件分片上传 DEMO</title>
    <script src="https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js"></script>
  </head>
  <body>
    <div>
      <input type="file" name="file" id="file" multiple />
      <button id="upload" onClick="uploadChunks()">上传</button>
      <button onClick="handlePause()">暂停</button>
      <button onClick="handleResume()">恢复</button>
    </div>
    <script>
      let abortControllerList = []; // 取消信号列表
      /**
       * @description: 封装fetch
       * @param {Object} FetchConfig fetch config
       * @return {Promise} fetch result
       */
      const requestApi = ({
        url,
        method = "GET",
        onProgress,
        ...fetchProps
      }) => {
        const controller = new AbortController();
        abortControllerList.push(controller);
        return new Promise(async (resolve, reject) => {
          const res = await fetch(url, {
            method,
            ...fetchProps,
            signal: controller.signal,
          });
          const total = res.headers.get("content-length");
          const reader = res.body.getReader(); //创建可读流
          const decoder = new TextDecoder();
          let loaded = 0;
          let data = "";
          while (true) {
            const { done, value } = await reader.read();
            loaded += value?.length || 0;
            data += decoder.decode(value);
            const progress = (loaded / total) * 100;
            console.log("上传进度：", progress);
            onProgress && onProgress(progress);
            if (done) {
              break;
            }
          }
          // 将请求成功的 xhr 从列表中删除
          const aCIndex = abortControllerList.findIndex(
            (c) => c.signal === controller.signal
          );
          abortControllerList.splice(aCIndex, 1);
          resolve(JSON.parse(data));
        });
      };

      // 文件分片
      const createFileChunk = (file) => {
        const fileSize = file.size; // 文件大小
        const chunkList = [];
        //计算文件切片总数
        const sliceSize = 5 * 1024 * 1024; // 每个文件切片大小定为5MB
        const totalSlice = Math.ceil(fileSize / sliceSize);
        for (let i = 1; i <= totalSlice; i++) {
          let chunk;
          if (i == totalSlice) {
            // 最后一片
            chunk = file.slice((i - 1) * sliceSize, fileSize - 1); //切割文件
          } else {
            chunk = file.slice((i - 1) * sliceSize, i * sliceSize);
          }
          chunkList.push({ file: chunk, fileSize });
        }
        console.log("一共分片：", totalSlice);
        return chunkList;
      };

      // 根据分片生成hash
      const calculateHash = (fileChunkList) => {
        return new Promise((resolve) => {
          const spark = new SparkMD5.ArrayBuffer();
          let percentage = 0;
          let count = 0;
          // 计算出hash
          const loadNext = (index) => {
            const reader = new FileReader(); // 文件阅读对象
            reader.readAsArrayBuffer(fileChunkList[index].file);
            reader.onload = (e) => {
              // 事件
              count++;
              spark.append(e.target.result);
              if (count === fileChunkList.length) {
                resolve(spark.end());
              } else {
                // 还没读完
                percentage += 100 / fileChunkList.length;
                console.log("计算hash值百分比：", percentage);
                loadNext(count);
              }
            };
          };
          loadNext(0);
        });
      };

      //上传分片
      const uploadChunks = async () => {
        const file = document.getElementById("file").files[0];
        const fileName = file.name; // 文件名
        const fileChunkList = createFileChunk(file);
        const fileHash = await calculateHash(fileChunkList); // 文件hash
        const { shouldUpload, uploadedList } = await verifyUpload(
          fileName,
          fileHash
        );
        if (!shouldUpload) {
          alert("秒传：上传成功");
          return;
        }
        const requestList = fileChunkList
          .map(({ file }, index) => ({
            file,
            fileHash,
            hash: `${fileHash}-${index}`,
          }))
          .filter(({ hash }) => !uploadedList.includes(hash))
          .map(({ file, fileHash, hash }, index) => {
            const formData = new FormData();
            formData.append("file", file);
            formData.append("fileHash", fileHash);
            formData.append("name", fileName);
            formData.append("hash", hash);
            return { formData };
          })
          .map(async ({ formData }) => {
            return requestApi({
              url: `http://localhost:3000`,
              method: "POST",
              body: formData,
            });
          });
        await Promise.all(requestList);
        // 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时
        //合并分片
        if (uploadedList.length + requestList.length === fileChunkList.length) {
          await mergeRequest(fileName, fileHash);
        }
      };

      // 合并分片
      const mergeRequest = async (fileName, fileHash) => {
        await requestApi({
          url: "http://localhost:3000/merge",
          method: "POST",
          headers: {
            "Content-Type": "application/json;charset=utf-8",
          },
          body: JSON.stringify({
            filename: fileName,
            fileHash,
          }),
        });
      };

      //文件秒传
      const verifyUpload = async (filename, fileHash) => {
        const data = await requestApi({
          url: "http://localhost:3000/verify",
          method: "POST",
          headers: {
            "Content-Type": "application/json;charset=utf-8",
          },
          body: JSON.stringify({
            filename,
            fileHash,
          }),
        });
        return data;
      };

      //断点续传
      const handlePause = () => {
        abortControllerList.forEach((controller) => controller?.abort());
        abortControllerList = [];
      };
      const handleResume = async () => {
        await uploadChunks();
      };
      //TODO 上传进度
    </script>
  </body>
</html>
